/*
 * This file is part of d3.
 * 
 * d3 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * d3 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with d3.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright 2010 Guilhelm Savin
 */
package org.ri2c.d3.tools;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.ConstructorDoc;
import com.sun.javadoc.ExecutableMemberDoc;
import com.sun.javadoc.FieldDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.PackageDoc;
import com.sun.javadoc.Parameter;
import com.sun.javadoc.ProgramElementDoc;
import com.sun.javadoc.RootDoc;
import com.sun.javadoc.Type;

public class D3Doclet {
	private static HashMap<String, PackageDoc> packagesDocumentation = new HashMap<String, PackageDoc>();
	private static HashMap<String, ClassDoc> classesDocumentation = new HashMap<String, ClassDoc>();
	private static String baseURL = "/api/";

	public static boolean start(RootDoc root) {
		String outputDirectory = ".";
		String headerFile = null;
		String footerFile = null;

		for (String[] option : root.options()) {
			if (option[0].equals("-d"))
				outputDirectory = option[1];
			else if (option[0].equals("-header"))
				headerFile = option[1];
			else if (option[0].equals("-footer"))
				footerFile = option[1];
			else if (option[0].equals("-base-url"))
				baseURL = option[1];
		}

		ClassDoc[] classes = root.classes();

		String header = getFileContent(headerFile);
		String footer = getFileContent(footerFile);
		// String navigationList = getNavigationList(root);

		for (ClassDoc classDoc : classes) {
			packagesDocumentation.put(classDoc.containingPackage().name(),
					classDoc.containingPackage());
			classesDocumentation.put(classDoc.qualifiedName(), classDoc);
		}

		{
			String indexPath = outputDirectory + File.separator + "index.html";

			File outFile = new File(indexPath);
			outFile.getParentFile().mkdirs();

			try {
				PrintWriter out = new PrintWriter(new FileWriter(outFile));

				LinkedList<String> packagesName = new LinkedList<String>(
						packagesDocumentation.keySet());
				Collections.sort(packagesName);

				out.write(header);
				out.write("<h1 class=\"title\" style=\"font-family: Impact; font-size: 50px; font-weight: normal;\">"
						+ "<span style=\"font-size:65px;\">d</span><sup>3</sup>"
						+ " : <span style=\"font-size:65px;\">d</span>ynamic and "
						+ "<span style=\"font-size:65px;\">d</span>ecentralized "
						+ "<span style=\"font-size:65px;\">d</span>istribution</h1>");

				out.printf(
						"<div class=\"index-preamble\">This documentation has been generated by the <span class=\"type-name\">%s</span> doclet.</div>",
						D3Doclet.class.getName());

				out.printf("<div class=\"package-content\">%n");

				if (packagesName.size() > 0) {

					out.printf("<div style=\"display: inline-block;\">%n");
					out.printf("<h1>Classes:</h1>%n");

					for (String p : packagesName) {
						PackageDoc pDoc = packagesDocumentation.get(p);
						String pName = pDoc == null ? p
								: getPackageNameDisplay(pDoc);

						out.printf("<h2>%s</h2>%n", pName);

						out.printf("<ul class=\"package-subpackage-entries\">%n");

						int max = 0;
						for (ClassDoc cDoc : pDoc.allClasses())
							max = Math.max(max, cDoc.name().length());

						for (ClassDoc cDoc : pDoc.allClasses()) {
							out.printf(
									"<li class=\"package-class-entry\" style=\"float: left; width: %dpx;\">%s</li>%n",
									max * 10, getTypeDisplay(cDoc));
						}
						out.printf("</ul>%n<br style=\"clear: both;\"/>%n");
					}
					out.printf("<br style=\"clear: both;\"/>%n");
					out.printf("</div>%n");
				}
				out.printf("</div>%n");
				out.write(footer);

				out.flush();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		for (ClassDoc classDoc : classes) {
			String docContent = getClassDocumentation(classDoc);
			String path = outputDirectory + File.separator
					+ classDoc.qualifiedName().replace(".", File.separator)
					+ ".html";

			System.out.printf("- writing %s%n", path);

			File outFile = new File(path);
			outFile.getParentFile().mkdirs();

			try {
				FileWriter out = new FileWriter(outFile);

				out.write(header);
				out.write(docContent);
				out.write(footer);

				out.flush();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		for (PackageDoc packageDoc : packagesDocumentation.values()) {
			String packageContent = getPackageDocumentation(packageDoc);
			String path = outputDirectory + File.separator
					+ packageDoc.name().replace(".", File.separator)
					+ File.separator + "index.html";

			System.out.printf("- writing %s%n", path);

			File outFile = new File(path);
			outFile.getParentFile().mkdirs();

			try {
				FileWriter out = new FileWriter(outFile);

				out.write(header);
				out.write(packageContent);
				out.write(footer);

				out.flush();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		return true;
	}

	public static String getFileContent(String path) {
		try {
			FileReader reader = new FileReader(path);
			StringWriter outString = new StringWriter();
			PrintWriter out = new PrintWriter(outString);

			char[] buffer = new char[1024];

			int r;

			while (reader.ready()) {
				r = reader.read(buffer, 0, 1024);
				out.write(buffer, 0, r);
			}

			return outString.toString();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return "";
	}

	public static String getClassDocumentation(ClassDoc classDoc) {
		StringWriter outString = new StringWriter();
		PrintWriter out = new PrintWriter(outString);

		out.printf("package %s%n",
				getPackageNameDisplay(classDoc.containingPackage()));
		out.printf("<div class=\"class-title\">%s %s</div>\n", classDoc
				.isClass() ? "Class" : (classDoc.isInterface() ? "Interface"
				: (classDoc.isEnum() ? "Enum"
						: (classDoc.isAnnotationType() ? "Annotation" : ""))),
				getTypeDisplay(classDoc));
		out.printf("<hr/>%n");

		LinkedList<String> superclasses = new LinkedList<String>();
		ClassDoc superclass = classDoc;

		while (superclass != null) {
			superclasses.addFirst(superclass.qualifiedName());
			superclass = superclass.superclass();
		}

		if (superclasses.size() > 0) {
			String indent = "&nbsp;&nbsp;&nbsp;";
			String corner = "<div style=\"display: inline-block; "
					+ "border-left: solid 1px black; border-bottom: solid 1px black;"
					+ "width: 5px; height: 10px; vertical-align: top; margin-bottom: 2px;\"></div>";
			out.printf("<div class=\"class-superclasses\">%n");
			for (int i = 0; i < superclasses.size(); i++) {
				out.printf("<div class=\"class-superclass\">");
				for (int j = 0; j < i; j++)
					out.print(indent);
				if (i > 0) {
					out.print(corner);
					out.print(indent);
				}

				ClassDoc superDoc = classesDocumentation.get(superclasses
						.get(i));

				out.printf("<span class=\"type-name\">%s</span>",
						superDoc == null ? superclasses.get(i) : superDoc
								.containingPackage().name()
								+ "."
								+ getTypeDisplay(superDoc));
				out.printf("</div>%n");
			}
			out.printf("</div>%n");
		}

		ClassDoc[] interfaces = classDoc.interfaces();

		if (interfaces != null && interfaces.length > 0) {
			out.printf("<h3>Implements:</h3>%n<ul class=\"class-interface-entries\">%n");
			for (ClassDoc i : interfaces)
				out.printf("<li class=\"class-interface-entry\">%s</li>%n",
						getTypeDisplay(i));
			out.printf("</ul>%n");
		}

		out.printf("<hr/>%n");

		out.printf("<div class=\"class-content\">%n");
		out.printf("<div class=\"class-comment\">%s</div>%n",
				classDoc.commentText());

		FieldDoc[] fields = classDoc.fields();

		/*
		 * Brief fields.
		 */
		if (fields != null && fields.length > 0) {
			out.printf("<div class=\"class-part-title\">Fields</div>%n");
			for (FieldDoc field : fields) {
				out.printf("<div class=\"class-part-item\">%n");
				out.printf(
						"<div class=\"class-field-brief-type type-name\">%s%s%s</div>",
						field.isStatic() ? "static " : "",
						field.isFinal() ? "final " : "", getTypeDisplay(field
								.type()));
				out.printf(
						"<div class=\"class-field-brief-name type-name\">%s</div>",
						field.name());
				out.printf("</div>%n");
			}
		}

		ConstructorDoc[] constructors = classDoc.constructors();

		/*
		 * Brief constructors.
		 */
		if (constructors != null && constructors.length > 0) {
			out.printf("<div class=\"class-part-title\">Constructors</div>%n");
			for (ConstructorDoc constDoc : constructors)
				out.printf(
						"<div class=\"class-part-item type-name\">%s</div>%n",
						getMethodNameDisplay(constDoc));
		}

		MethodDoc[] methods = classDoc.methods();

		/*
		 * Brief methods.
		 */
		if (methods != null && methods.length > 0) {
			out.printf("<div class=\"class-part-title\">Methods</div>%n");
			for (MethodDoc methodDoc : classDoc.methods())
				out.write(getClassMethodDocumentation(methodDoc, true));
		}

		out.printf("<br/><hr/><br/>%n");

		if (fields != null && fields.length > 0) {
			String sep = "";
			out.printf("<div class=\"class-part-title\">Fields detail</div>%n<br/>%n");
			for (FieldDoc fieldDoc : fields) {
				out.write(sep);
				sep = "<hr/>\n";
				out.printf(
						"<div class=\"class-field-name type-name\">%s</div>%n",
						fieldDoc.name());
				out.printf(
						"<div class=\"class-field-prototype type-name\">%s %s%s %s</div>%n",
						getAccessType(fieldDoc), getFieldModifier(fieldDoc),
						getTypeDisplay(fieldDoc.type()), fieldDoc.name());
				out.printf("<div class=\"class-field-comment\">%s</div>%n",
						fieldDoc.commentText());
			}
		}

		if (methods != null && methods.length > 0) {
			String sep = "";
			out.printf("<div class=\"class-part-title\">Methods detail</div>%n<br/>%n");
			for (MethodDoc methodDoc : methods) {
				out.write(sep);
				sep = "<hr/>\n";
				out.printf(
						"<div class=\"class-field-name type-name\">%s</div>%n",
						methodDoc.name());
				out.printf(
						"<div class=\"class-field-prototype type-name\">%s %s%s %s</div>%n",
						getAccessType(methodDoc), getMethodModifier(methodDoc),
						getTypeDisplay(methodDoc.returnType()),
						getMethodNameDisplay(methodDoc));
				out.printf("<div class=\"class-field-comment\">%s</div>%n",
						methodDoc.commentText());
			}
		}

		/*
		 * End of class content.
		 */
		out.printf("</div>%n");

		return outString.toString();
	}

	public static String getMethodModifier(MethodDoc methodDoc) {
		return String.format("%s%s%s%s", methodDoc.isAbstract() ? "abstract "
				: "", methodDoc.isNative() ? "native " : "", methodDoc
				.isSynchronized() ? "synchronized " : "",
				getElementModifier(methodDoc));
	}

	public static String getFieldModifier(FieldDoc fieldDoc) {
		return String.format("%s%s%s",
				fieldDoc.isVolatile() ? "volatile " : "",
				fieldDoc.isTransient() ? "transient " : "",
				getElementModifier(fieldDoc));
	}

	public static String getElementModifier(ProgramElementDoc elementDoc) {
		return String.format("%s%s", elementDoc.isStatic() ? "static " : "",
				elementDoc.isFinal() ? "final " : "");
	}

	public static String getAccessType(ProgramElementDoc elementDoc) {
		if (elementDoc.isPublic())
			return "public";
		else if (elementDoc.isProtected())
			return "protected";
		else if (elementDoc.isPrivate())
			return "private";
		else
			return "";
	}

	public static String getClassMethodDocumentation(MethodDoc methodDoc,
			boolean brief) {
		StringWriter outString = new StringWriter();
		PrintWriter out = new PrintWriter(outString);

		out.printf("<div class=\"class-method%s\">%n", brief ? "-brief" : "");

		String comment = methodDoc.commentText();

		if (brief) {
			if (comment.indexOf('.') > 0)
				comment = comment.substring(0, comment.indexOf('.'));
			out.printf(
					"<div class=\"class-method-brief-return type-name\">%s%s%s</div>",
					methodDoc.isStatic() ? "static " : "",
					methodDoc.isFinal() ? "final " : "",
					getTypeDisplay(methodDoc.returnType()));
			out.printf(
					"<div class=\"class-method-brief-name type-name\">%s</div>",
					getMethodNameDisplay(methodDoc));
			if (comment.length() > 0) {
				out.printf(
						"<div class=\"class-method-brief-comment\">%s</div>%n",
						comment);
			}
		}
		out.printf("</div>%n");
		return outString.toString();
	}

	public static String getMethodNameDisplay(ExecutableMemberDoc methodDoc) {
		String display = "<span style=\"font-weight: bold;\">"
				+ methodDoc.name() + "</span>(";

		String sep = "";

		for (Parameter p : methodDoc.parameters()) {
			display = String.format(
					"%s%s%s <span style=\"font-weight: normal;\">%s</span>",
					display, sep, getTypeDisplay(p.type()), p.name());
			sep = ", ";
		}

		display += ")";

		return display;
	}

	public static String getTypeDisplay(Type type) {
		ClassDoc classDoc = type.asClassDoc();

		if (!classesDocumentation.containsKey(type.qualifiedTypeName()))
			return "<span class=\"type-name\">" + type.qualifiedTypeName()
					+ "</span>";
		else
			return String
					.format("<span class=\"type-name\"><a href=\"%s%s.html\">%s</a></span>",
							baseURL,
							classDoc.qualifiedName().replace(".", "/"),
							classDoc.name());
	}

	public static String getPackageNameDisplay(PackageDoc packageDoc) {
		String display = "";

		String name = packageDoc.name();
		String sep = "";

		while (name.length() > 0) {
			PackageDoc doc = packagesDocumentation.get(name);
			String briefName = name.indexOf('.') > 0 ? name.substring(name
					.lastIndexOf('.') + 1) : name;

			if (doc == null) {
				display = briefName + sep + display;
				sep = ".";
			} else {
				display = String.format(
						"<a href=\"%s%s/index.html\">%s</a>%s%s", baseURL,
						name.replace(".", "/"), briefName, sep, display);
				sep = ".";
			}

			name = name.indexOf('.') > 0 ? name.substring(0,
					name.lastIndexOf('.')) : "";
		}

		return "<span class=\"type-name\">" + display + "</span>";
	}

	public static String getPackageDocumentation(PackageDoc packageDoc) {
		StringWriter outString = new StringWriter();
		PrintWriter out = new PrintWriter(outString);

		LinkedList<String> classes = new LinkedList<String>();

		for (ClassDoc classDoc : packageDoc.allClasses()) {
			classes.add(classDoc.qualifiedName());
		}

		Collections.sort(classes);

		out.printf("package<div class=\"package-title\">%s</div>%n",
				getPackageNameDisplay(packageDoc));
		out.printf("<hr/>%n");

		out.printf("<div class=\"package-content\">%n");

		out.printf("<div style=\"display: inline-block; vertical-align: top;\">%n");
		out.printf("<h3>Package classes:</h3><ul class=\"package-class-entries\">%n");
		for (String className : classes) {
			out.printf("<li class=\"package-class-entry\">%s</li>%n",
					getTypeDisplay(classesDocumentation.get(className)));
		}
		out.printf("</ul>%n");
		out.printf("</div>%n");

		LinkedList<String> subpackages = new LinkedList<String>();

		for (String p : packagesDocumentation.keySet()) {
			if (p.startsWith(packageDoc.name()) && !p.equals(packageDoc.name())) {
				subpackages.add(p);
			}
		}

		if (subpackages.size() > 0) {
			Collections.sort(subpackages);

			out.printf("<div style=\"display: inline-block;\">%n");
			out.printf("<h3>Sub-packages:</h3><ul class=\"package-subpackage-entries\">%n");
			for (String p : subpackages) {
				PackageDoc pDoc = packagesDocumentation.get(p);
				String pName = pDoc == null ? p : getPackageNameDisplay(pDoc);

				out.printf("<li class=\"package-subpackage-entry\">%s</li>%n",
						pName);
			}
			out.printf("</ul>%n");
			out.printf("</div>%n");
		}
		out.printf("</div>%n");

		return outString.toString();
	}

	public static int optionLength(String option) {
		if (option.matches("^-(d|header|footer|base-url)$")) {
			return 2;
		}

		return 0;
	}
}
